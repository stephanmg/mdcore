.TH "/Users/stephan/Code/git/mdcore/src/potential.c" 3 "Thu Apr 24 2014" "Version 0.1.5" "mdcore" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/Users/stephan/Code/git/mdcore/src/potential.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <malloc/malloc\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <float\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'errs\&.h'\fP
.br
\fC#include 'fptype\&.h'\fP
.br
\fC#include 'potential\&.h'\fP
.br
\fC#include 'potential_eval\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBvector\fP(elcount, type)   \fB__attribute__\fP((vector_size((elcount)*sizeof(type)))) type"
.br
.ti -1c
.RI "#define \fBerror\fP(\fBid\fP)   ( \fBpotential_err\fP = \fBerrs_register\fP( \fBid\fP , \fBpotential_err_msg\fP[-(\fBid\fP)] , __LINE__ , __FUNCTION__ , __FILE__ ) )"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBpotential_switch\fP (double \fBr\fP, double A, double B)"
.br
.RI "\fISwitching function\&. \fP"
.ti -1c
.RI "double \fBpotential_switch_p\fP (double \fBr\fP, double A, double B)"
.br
.ti -1c
.RI "double \fBpotential_LJ126\fP (double \fBr\fP, double A, double B)"
.br
.RI "\fIA basic 12-6 Lennard-Jones potential\&. \fP"
.ti -1c
.RI "double \fBpotential_LJ126_p\fP (double \fBr\fP, double A, double B)"
.br
.RI "\fIA basic 12-6 Lennard-Jones potential (first derivative)\&. \fP"
.ti -1c
.RI "double \fBpotential_LJ126_6p\fP (double \fBr\fP, double A, double B)"
.br
.RI "\fIA basic 12-6 Lennard-Jones potential (sixth derivative)\&. \fP"
.ti -1c
.RI "double \fBpotential_Coulomb\fP (double \fBr\fP)"
.br
.RI "\fIThe Coulomb potential\&. \fP"
.ti -1c
.RI "double \fBpotential_Coulomb_p\fP (double \fBr\fP)"
.br
.RI "\fIThe Coulomb potential (first derivative)\&. \fP"
.ti -1c
.RI "double \fBpotential_Coulomb_6p\fP (double \fBr\fP)"
.br
.RI "\fITheCoulomb potential (sixth derivative)\&. \fP"
.ti -1c
.RI "double \fBpotential_Ewald\fP (double \fBr\fP, double \fBkappa\fP)"
.br
.RI "\fIThe short-range part of an Ewald summation\&. \fP"
.ti -1c
.RI "double \fBpotential_Ewald_p\fP (double \fBr\fP, double \fBkappa\fP)"
.br
.RI "\fIThe short-range part of an Ewald summation (first derivative)\&. \fP"
.ti -1c
.RI "double \fBpotential_Ewald_6p\fP (double \fBr\fP, double \fBkappa\fP)"
.br
.RI "\fIThe short-range part of an Ewald summation (sixth derivative)\&. \fP"
.ti -1c
.RI "double \fBpotential_create_harmonic_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_harmonic\fP (double a, double b, double K, double r0, double tol)"
.br
.RI "\fICreates a harmonic bond \fBpotential\fP\&. \fP"
.ti -1c
.RI "double \fBpotential_create_harmonic_dihedral_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_dihedral_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_dihedral_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_harmonic_dihedral\fP (double K, int n, double delta, double tol)"
.br
.RI "\fICreates a harmonic dihedral \fBpotential\fP\&. \fP"
.ti -1c
.RI "double \fBpotential_create_harmonic_angle_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_angle_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_angle_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_harmonic_angle\fP (double a, double b, double K, double theta0, double tol)"
.br
.RI "\fICreates a harmonic angle \fBpotential\fP\&. \fP"
.ti -1c
.RI "double \fBpotential_create_Ewald_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_Ewald_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_Ewald_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_Ewald\fP (double a, double b, double q, double \fBkappa\fP, double tol)"
.br
.RI "\fICreates a \fBpotential\fP representing the real-space part of an Ewald potential\&. \fP"
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_LJ126_Ewald\fP (double a, double b, double A, double B, double q, double \fBkappa\fP, double tol)"
.br
.RI "\fICreates a \fBpotential\fP representing the sum of a 12-6 Lennard-Jones potential and the real-space part of an Ewald potential\&. \fP"
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_LJ126_Ewald_switch\fP (double a, double b, double A, double B, double q, double \fBkappa\fP, double s, double tol)"
.br
.RI "\fICreates a \fBpotential\fP representing the sum of a 12-6 Lennard-Jones potential with a switching distance and the real-space part of an Ewald potential\&. \fP"
.ti -1c
.RI "double \fBpotential_create_Coulomb_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_Coulomb_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_Coulomb_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_Coulomb\fP (double a, double b, double q, double tol)"
.br
.RI "\fICreates a \fBpotential\fP representing a shifted Coulomb potential\&. \fP"
.ti -1c
.RI "double \fBpotential_create_LJ126_Coulomb_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Coulomb_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Coulomb_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_LJ126_Coulomb\fP (double a, double b, double A, double B, double q, double tol)"
.br
.RI "\fICreates a \fBpotential\fP representing the sum of a 12-6 Lennard-Jones potential and a shifted Coulomb potential\&. \fP"
.ti -1c
.RI "double \fBpotential_create_LJ126_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_LJ126\fP (double a, double b, double A, double B, double tol)"
.br
.RI "\fICreates a \fBpotential\fP representing a 12-6 Lennard-Jones potential\&. \fP"
.ti -1c
.RI "double \fBpotential_create_LJ126_switch_f\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_switch_dfdr\fP (double \fBr\fP)"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_switch_d6fdr6\fP (double \fBr\fP)"
.br
.ti -1c
.RI "struct \fBpotential\fP * \fBpotential_create_LJ126_switch\fP (double a, double b, double A, double B, double s, double tol)"
.br
.RI "\fICreates a \fBpotential\fP representing a switched 12-6 Lennard-Jones potential\&. \fP"
.ti -1c
.RI "void \fBpotential_clear\fP (struct \fBpotential\fP *p)"
.br
.RI "\fIFree the memory associated with the given potential\&. \fP"
.ti -1c
.RI "int \fBpotential_init\fP (struct \fBpotential\fP *p, double(*\fBf\fP)(double), double(*fp)(double), double(*f6p)(double), \fBFPTYPE\fP a, \fBFPTYPE\fP b, \fBFPTYPE\fP tol)"
.br
.RI "\fIConstruct a \fBpotential\fP from the given function\&. \fP"
.ti -1c
.RI "int \fBpotential_getfp\fP (double(*\fBf\fP)(double), int n, \fBFPTYPE\fP *\fBx\fP, double *fp)"
.br
.RI "\fICompute the optimal first derivatives for the given set of nodes\&. \fP"
.ti -1c
.RI "int \fBpotential_getfp_fixend\fP (double(*\fBf\fP)(double), double fpa, double fpb, int n, \fBFPTYPE\fP *\fBx\fP, double *fp)"
.br
.ti -1c
.RI "int \fBpotential_getcoeffs\fP (double(*\fBf\fP)(double), double(*fp)(double), \fBFPTYPE\fP *xi, int n, \fBFPTYPE\fP *\fBc\fP, \fBFPTYPE\fP *err)"
.br
.RI "\fICompute the interpolation coefficients over a given set of nodes\&. \fP"
.ti -1c
.RI "double \fBpotential_getalpha\fP (double(*f6p)(double), double a, double b)"
.br
.RI "\fICompute the parameter $\alpha$ for the optimal node distribution\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBpotential_err\fP = \fBpotential_err_ok\fP"
.br
.ti -1c
.RI "\fBFPTYPE\fP \fBc_null\fP [] = { \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP }"
.br
.ti -1c
.RI "struct \fBpotential\fP \fBpotential_null\fP = { { \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP } , \fBc_null\fP , 0\&.0 , DBL_MAX , \fBpotential_flag_none\fP , 1 }"
.br
.ti -1c
.RI "char * \fBpotential_err_msg\fP [6]"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_K\fP"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_r0\fP"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_dihedral_K\fP"
.br
.ti -1c
.RI "int \fBpotential_create_harmonic_dihedral_n\fP"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_dihedral_delta\fP"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_angle_K\fP"
.br
.ti -1c
.RI "double \fBpotential_create_harmonic_angle_theta0\fP"
.br
.ti -1c
.RI "double \fBpotential_create_Ewald_q\fP"
.br
.ti -1c
.RI "double \fBpotential_create_Ewald_kappa\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_A\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_B\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_kappa\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_q\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_A\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_B\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_kappa\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_q\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_s\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Ewald_switch_cutoff\fP"
.br
.ti -1c
.RI "double \fBpotential_create_Coulomb_q\fP"
.br
.ti -1c
.RI "double \fBpotential_create_Coulomb_b\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Coulomb_q\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Coulomb_b\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Coulomb_A\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_Coulomb_B\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_A\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_B\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_switch_A\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_switch_B\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_switch_s\fP"
.br
.ti -1c
.RI "double \fBpotential_create_LJ126_switch_cutoff\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define error(\fBid\fP)   ( \fBpotential_err\fP = \fBerrs_register\fP( \fBid\fP , \fBpotential_err_msg\fP[-(\fBid\fP)] , __LINE__ , __FUNCTION__ , __FILE__ ) )"

.SS "#define vector(elcount, type)   \fB__attribute__\fP((vector_size((elcount)*sizeof(type)))) type"
Macro to easily define vector types\&. 
.SH "Function Documentation"
.PP 
.SS "void potential_clear (struct \fBpotential\fP *p)"

.PP
Free the memory associated with the given potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP Pointer to the \fBpotential\fP to clear\&. 
.RE
.PP

.SS "double potential_Coulomb (doubler)\fC [inline]\fP"

.PP
The Coulomb potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The potential $ \frac{1}{4\pi r} $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "double potential_Coulomb_6p (doubler)\fC [inline]\fP"

.PP
TheCoulomb potential (sixth derivative)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The sixth derivative of the potential $ \frac{1}{4\pi r} $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "double potential_Coulomb_p (doubler)\fC [inline]\fP"

.PP
The Coulomb potential (first derivative)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The first derivative of the potential $ \frac{1}{4\pi r} $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "struct \fBpotential\fP* potential_create_Coulomb (doublea, doubleb, doubleq, doubletol)"

.PP
Creates a \fBpotential\fP representing a shifted Coulomb potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fIq\fP The charge scaling of the potential\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ \frac{1}{4\pi r} $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "double potential_create_Coulomb_d6fdr6 (doubler)"

.SS "double potential_create_Coulomb_dfdr (doubler)"

.SS "double potential_create_Coulomb_f (doubler)"

.SS "struct \fBpotential\fP* potential_create_Ewald (doublea, doubleb, doubleq, doublekappa, doubletol)"

.PP
Creates a \fBpotential\fP representing the real-space part of an Ewald potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fIq\fP The charge scaling of the potential\&. 
.br
\fIkappa\fP The screening distance of the Ewald potential\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ q\frac{\mbox{erfc}(\kappa r}{r} $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "double potential_create_Ewald_d6fdr6 (doubler)"

.SS "double potential_create_Ewald_dfdr (doubler)"

.SS "double potential_create_Ewald_f (doubler)"

.SS "struct \fBpotential\fP* potential_create_harmonic (doublea, doubleb, doubleK, doubler0, doubletol)"

.PP
Creates a harmonic bond \fBpotential\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fIK\fP The energy of the bond\&. 
.br
\fIr0\fP The minimum energy distance\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ K(r-r_0)^2 $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "struct \fBpotential\fP* potential_create_harmonic_angle (doublea, doubleb, doubleK, doubletheta0, doubletol)"

.PP
Creates a harmonic angle \fBpotential\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest angle for which the potential will be constructed\&. 
.br
\fIb\fP The largest angle for which the potential will be constructed\&. 
.br
\fIK\fP The energy of the angle\&. 
.br
\fItheta0\fP The minimum energy angle\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ K(\arccos(r)-r_0)^2 $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "double potential_create_harmonic_angle_d6fdr6 (doubler)"

.SS "double potential_create_harmonic_angle_dfdr (doubler)"

.SS "double potential_create_harmonic_angle_f (doubler)"

.SS "double potential_create_harmonic_d6fdr6 (doubler)"

.SS "double potential_create_harmonic_dfdr (doubler)"

.SS "struct \fBpotential\fP* potential_create_harmonic_dihedral (doubleK, intn, doubledelta, doubletol)"

.PP
Creates a harmonic dihedral \fBpotential\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK\fP The energy of the dihedral\&. 
.br
\fIn\fP The multiplicity of the dihedral\&. 
.br
\fIdelta\fP The minimum energy dihedral\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ K(1 + \cos(n\arccos(r)-delta) $ in $[-1,1]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "double potential_create_harmonic_dihedral_d6fdr6 (doubler)"

.SS "double potential_create_harmonic_dihedral_dfdr (doubler)"

.SS "double potential_create_harmonic_dihedral_f (doubler)"

.SS "double potential_create_harmonic_f (doubler)"

.SS "struct \fBpotential\fP* potential_create_LJ126 (doublea, doubleb, doubleA, doubleB, doubletol)"

.PP
Creates a \fBpotential\fP representing a 12-6 Lennard-Jones potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fIA\fP The first parameter of the Lennard-Jones potential\&. 
.br
\fIB\fP The second parameter of the Lennard-Jones potential\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ \left( \frac{A}{r^{12}} - \frac{B}{r^6} \right) $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "struct \fBpotential\fP* potential_create_LJ126_Coulomb (doublea, doubleb, doubleA, doubleB, doubleq, doubletol)"

.PP
Creates a \fBpotential\fP representing the sum of a 12-6 Lennard-Jones potential and a shifted Coulomb potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fIA\fP The first parameter of the Lennard-Jones potential\&. 
.br
\fIB\fP The second parameter of the Lennard-Jones potential\&. 
.br
\fIq\fP The charge scaling of the potential\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ \left( \frac{A}{r^{12}} - \frac{B}{r^6} \right) $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "double potential_create_LJ126_Coulomb_d6fdr6 (doubler)"

.SS "double potential_create_LJ126_Coulomb_dfdr (doubler)"

.SS "double potential_create_LJ126_Coulomb_f (doubler)"

.SS "double potential_create_LJ126_d6fdr6 (doubler)"

.SS "double potential_create_LJ126_dfdr (doubler)"

.SS "struct \fBpotential\fP* potential_create_LJ126_Ewald (doublea, doubleb, doubleA, doubleB, doubleq, doublekappa, doubletol)"

.PP
Creates a \fBpotential\fP representing the sum of a 12-6 Lennard-Jones potential and the real-space part of an Ewald potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fIA\fP The first parameter of the Lennard-Jones potential\&. 
.br
\fIB\fP The second parameter of the Lennard-Jones potential\&. 
.br
\fIq\fP The charge scaling of the potential\&. 
.br
\fIkappa\fP The screening distance of the Ewald potential\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ \left( \frac{A}{r^{12}} - \frac{B}{r^6} \right) $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "double potential_create_LJ126_Ewald_d6fdr6 (doubler)"

.SS "double potential_create_LJ126_Ewald_dfdr (doubler)"

.SS "double potential_create_LJ126_Ewald_f (doubler)"

.SS "struct \fBpotential\fP* potential_create_LJ126_Ewald_switch (doublea, doubleb, doubleA, doubleB, doubleq, doublekappa, doubles, doubletol)"

.PP
Creates a \fBpotential\fP representing the sum of a 12-6 Lennard-Jones potential with a switching distance and the real-space part of an Ewald potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fIA\fP The first parameter of the Lennard-Jones potential\&. 
.br
\fIB\fP The second parameter of the Lennard-Jones potential\&. 
.br
\fIq\fP The charge scaling of the potential\&. 
.br
\fIs\fP The switching distance\&. 
.br
\fIkappa\fP The screening distance of the Ewald potential\&. 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ \left( \frac{A}{r^{12}} - \frac{B}{r^6} \right) $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "double potential_create_LJ126_Ewald_switch_d6fdr6 (doubler)"

.SS "double potential_create_LJ126_Ewald_switch_dfdr (doubler)"

.SS "double potential_create_LJ126_Ewald_switch_f (doubler)"

.SS "double potential_create_LJ126_f (doubler)"

.SS "struct \fBpotential\fP* potential_create_LJ126_switch (doublea, doubleb, doubleA, doubleB, doubles, doubletol)"

.PP
Creates a \fBpotential\fP representing a switched 12-6 Lennard-Jones potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fIA\fP The first parameter of the Lennard-Jones potential\&. 
.br
\fIB\fP The second parameter of the Lennard-Jones potential\&. 
.br
\fIs\fP The switchting length 
.br
\fItol\fP The tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A newly-allocated \fBpotential\fP representing the potential $ \left( \frac{A}{r^{12}} - \frac{B}{r^6} \right) $ in $[a,b]$ or \fCNULL\fP on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "double potential_create_LJ126_switch_d6fdr6 (doubler)"

.SS "double potential_create_LJ126_switch_dfdr (doubler)"

.SS "double potential_create_LJ126_switch_f (doubler)"

.SS "double potential_Ewald (doubler, doublekappa)\fC [inline]\fP"

.PP
The short-range part of an Ewald summation\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&. 
.br
\fIkappa\fP The screening length of the Ewald summation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The potential $ \frac{\mbox{erfc}( \kappa r )}{r} $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "double potential_Ewald_6p (doubler, doublekappa)\fC [inline]\fP"

.PP
The short-range part of an Ewald summation (sixth derivative)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&. 
.br
\fIkappa\fP The screening length of the Ewald summation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The sixth derivative of the potential $ \frac{\mbox{erfc}( \kappa r )}{r} $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "double potential_Ewald_p (doubler, doublekappa)\fC [inline]\fP"

.PP
The short-range part of an Ewald summation (first derivative)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&. 
.br
\fIkappa\fP The screening length of the Ewald summation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The first derivative of the potential $ \frac{\mbox{erfc}( \kappa r )}{r} $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "double potential_getalpha (double(*)(double)f6p, doublea, doubleb)"

.PP
Compute the parameter $\alpha$ for the optimal node distribution\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf6p\fP Pointer to a function representing the 6th derivative of the interpoland\&. 
.br
\fIa\fP Left limit of the interpolation\&. 
.br
\fIb\fP Right limit of the interpolation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The computed value for $\alpha$\&.
.RE
.PP
The value $\alpha$ is computed using Brent's algortihm to 4 decimal digits\&. 
.SS "int potential_getcoeffs (double(*)(double)f, double(*)(double)fp, \fBFPTYPE\fP *xi, intn, \fBFPTYPE\fP *c, \fBFPTYPE\fP *err)"

.PP
Compute the interpolation coefficients over a given set of nodes\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf\fP Pointer to the function to be interpolated\&. 
.br
\fIfp\fP Pointer to the first derivative of \fCf\fP\&. 
.br
\fIxi\fP Pointer to an array of nodes between whicht the function \fCf\fP will be interpolated\&. 
.br
\fIn\fP Number of nodes in \fCxi\fP\&. 
.br
\fIc\fP Pointer to an array in which to store the interpolation coefficients\&. 
.br
\fIerr\fP Pointer to a floating-point value in which an approximation of the interpolation error, relative to the maximum of f in each interval, is stored\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBpotential_err_ok\fP or < 0 on error (see \fBpotential_err\fP)\&.
.RE
.PP
Compute the coefficients of the function \fCf\fP with derivative \fCfp\fP over the \fCn\fP intervals between the \fCxi\fP and store an estimate of the maximum locally relative interpolation error in \fCerr\fP\&.
.PP
The array to which \fCc\fP points must be large enough to hold at least \fBpotential_degree\fP x \fCn\fP values of type \fBFPTYPE\fP\&. 
.SS "int potential_getfp (double(*)(double)f, intn, \fBFPTYPE\fP *x, double *fp)"

.PP
Compute the optimal first derivatives for the given set of nodes\&. 
.PP
\fBParameters:\fP
.RS 4
\fIf\fP Pointer to the function to be interpolated\&. 
.br
\fIn\fP Number of intervals\&. 
.br
\fIxi\fP Pointer to an array of nodes between whicht the function \fCf\fP will be interpolated\&. 
.br
\fIfp\fP Pointer to an array in which to store the first derivatives of \fCf\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBpotential_err_ok\fP or < 0 on error (see \fBpotential_err\fP)\&. 
.RE
.PP

.SS "int potential_getfp_fixend (double(*)(double)f, doublefpa, doublefpb, intn, \fBFPTYPE\fP *x, double *fp)"

.SS "int potential_init (struct \fBpotential\fP *p, double(*)(double)f, double(*)(double)fp, double(*)(double)f6p, \fBFPTYPE\fPa, \fBFPTYPE\fPb, \fBFPTYPE\fPtol)"

.PP
Construct a \fBpotential\fP from the given function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP A pointer to an empty \fBpotential\fP\&. 
.br
\fIf\fP A pointer to the potential function to be interpolated\&. 
.br
\fIfp\fP A pointer to the first derivative of \fCf\fP\&. 
.br
\fIf6p\fP A pointer to the sixth derivative of \fCf\fP\&. 
.br
\fIa\fP The smallest radius for which the potential will be constructed\&. 
.br
\fIb\fP The largest radius for which the potential will be constructed\&. 
.br
\fItol\fP The absolute tolerance to which the interpolation should match the exact potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBpotential_err_ok\fP or <0 on error (see \fBpotential_err\fP)\&.
.RE
.PP
Computes an interpolated potential function from \fCf\fP in \fC\fP[a,b] to the locally relative tolerance \fCtol\fP\&.
.PP
The sixth derivative \fCf6p\fP is used to compute the optimal node distribution\&. If \fCf6p\fP is \fCNULL\fP, the derivative is approximated numerically\&.
.PP
The zeroth interval contains a linear extension of \fCf\fP for values < a\&. 
.SS "double potential_LJ126 (doubler, doubleA, doubleB)\fC [inline]\fP"

.PP
A basic 12-6 Lennard-Jones potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&. 
.br
\fIA\fP First parameter of the potential\&. 
.br
\fIB\fP Second parameter of the potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The potential $ \left( \frac{A}{r^{12}} - \frac{B}{r^6} \right) $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "double potential_LJ126_6p (doubler, doubleA, doubleB)\fC [inline]\fP"

.PP
A basic 12-6 Lennard-Jones potential (sixth derivative)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&. 
.br
\fIA\fP First parameter of the potential\&. 
.br
\fIB\fP Second parameter of the potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The sixth derivative of the potential $ \left( \frac{A}{r^{12}} - \frac{B}{r^6} \right) $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "double potential_LJ126_p (doubler, doubleA, doubleB)\fC [inline]\fP"

.PP
A basic 12-6 Lennard-Jones potential (first derivative)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The interaction radius\&. 
.br
\fIA\fP First parameter of the potential\&. 
.br
\fIB\fP Second parameter of the potential\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The first derivative of the potential $ \left( \frac{A}{r^{12}} - \frac{B}{r^6} \right) $ evaluated at \fCr\fP\&. 
.RE
.PP

.SS "double potential_switch (doubler, doubleA, doubleB)\fC [inline]\fP"

.PP
Switching function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP The radius\&. 
.br
\fIA\fP The start of the switching region\&. 
.br
\fIB\fP The end of the switching region\&. 
.RE
.PP

.SS "double potential_switch_p (doubler, doubleA, doubleB)\fC [inline]\fP"

.SH "Variable Documentation"
.PP 
.SS "\fBFPTYPE\fP c_null[] = { \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP }"
The null potential 
.SS "double potential_create_Coulomb_b"

.SS "double potential_create_Coulomb_q"

.SS "double potential_create_Ewald_kappa"

.SS "double potential_create_Ewald_q"

.SS "double potential_create_harmonic_angle_K"

.SS "double potential_create_harmonic_angle_theta0"

.SS "double potential_create_harmonic_dihedral_delta"

.SS "double potential_create_harmonic_dihedral_K"

.SS "int potential_create_harmonic_dihedral_n"

.SS "double potential_create_harmonic_K"

.SS "double potential_create_harmonic_r0"

.SS "double potential_create_LJ126_A"

.SS "double potential_create_LJ126_B"

.SS "double potential_create_LJ126_Coulomb_A"

.SS "double potential_create_LJ126_Coulomb_b"

.SS "double potential_create_LJ126_Coulomb_B"

.SS "double potential_create_LJ126_Coulomb_q"

.SS "double potential_create_LJ126_Ewald_A"

.SS "double potential_create_LJ126_Ewald_B"

.SS "double potential_create_LJ126_Ewald_kappa"

.SS "double potential_create_LJ126_Ewald_q"

.SS "double potential_create_LJ126_Ewald_switch_A"

.SS "double potential_create_LJ126_Ewald_switch_B"

.SS "double potential_create_LJ126_Ewald_switch_cutoff"

.SS "double potential_create_LJ126_Ewald_switch_kappa"

.SS "double potential_create_LJ126_Ewald_switch_q"

.SS "double potential_create_LJ126_Ewald_switch_s"

.SS "double potential_create_LJ126_switch_A"

.SS "double potential_create_LJ126_switch_B"

.SS "double potential_create_LJ126_switch_cutoff"

.SS "double potential_create_LJ126_switch_s"

.SS "int potential_err = \fBpotential_err_ok\fP"
The last error 
.SS "char* potential_err_msg[6]"
\fBInitial value:\fP
.PP
.nf
= {
        "Nothing bad happened\&.",
    "An unexpected NULL pointer was encountered\&.",
    "A call to malloc failed, probably due to insufficient memory\&.",
    "The requested value was out of bounds\&.",
    "Not yet implemented\&.",
    "Maximum number of intervals reached before tolerance satisfied\&."
        }
.fi
.SS "struct \fBpotential\fP potential_null = { { \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP , \fBFPTYPE_ZERO\fP } , \fBc_null\fP , 0\&.0 , DBL_MAX , \fBpotential_flag_none\fP , 1 }"
Fictitious null potential\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for mdcore from the source code\&.
