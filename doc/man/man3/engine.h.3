.TH "/Users/stephan/Code/git/mdcore/src/engine.h" 3 "Thu Apr 24 2014" "Version 0.1.5" "mdcore" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/Users/stephan/Code/git/mdcore/src/engine.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBengine\fP"
.br
.ti -1c
.RI "struct \fBengine_set\fP"
.br
.ti -1c
.RI "struct \fBengine_comm\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBengine_err_ok\fP   0"
.br
.ti -1c
.RI "#define \fBengine_err_null\fP   -1"
.br
.ti -1c
.RI "#define \fBengine_err_malloc\fP   -2"
.br
.ti -1c
.RI "#define \fBengine_err_space\fP   -3"
.br
.ti -1c
.RI "#define \fBengine_err_pthread\fP   -4"
.br
.ti -1c
.RI "#define \fBengine_err_runner\fP   -5"
.br
.ti -1c
.RI "#define \fBengine_err_range\fP   -6"
.br
.ti -1c
.RI "#define \fBengine_err_cell\fP   -7"
.br
.ti -1c
.RI "#define \fBengine_err_domain\fP   -8"
.br
.ti -1c
.RI "#define \fBengine_err_nompi\fP   -9"
.br
.ti -1c
.RI "#define \fBengine_err_mpi\fP   -10"
.br
.ti -1c
.RI "#define \fBengine_err_bond\fP   -11"
.br
.ti -1c
.RI "#define \fBengine_err_angle\fP   -12"
.br
.ti -1c
.RI "#define \fBengine_err_reader\fP   -13"
.br
.ti -1c
.RI "#define \fBengine_err_psf\fP   -14"
.br
.ti -1c
.RI "#define \fBengine_err_pdb\fP   -15"
.br
.ti -1c
.RI "#define \fBengine_err_cpf\fP   -16"
.br
.ti -1c
.RI "#define \fBengine_err_potential\fP   -17"
.br
.ti -1c
.RI "#define \fBengine_err_exclusion\fP   -18"
.br
.ti -1c
.RI "#define \fBengine_err_sets\fP   -19"
.br
.ti -1c
.RI "#define \fBengine_err_dihedral\fP   -20"
.br
.ti -1c
.RI "#define \fBengine_err_cuda\fP   -21"
.br
.ti -1c
.RI "#define \fBengine_err_nocuda\fP   -22"
.br
.ti -1c
.RI "#define \fBengine_err_cudasp\fP   -23"
.br
.ti -1c
.RI "#define \fBengine_err_maxparts\fP   -24"
.br
.ti -1c
.RI "#define \fBengine_err_queue\fP   -25"
.br
.ti -1c
.RI "#define \fBengine_err_rigid\fP   -26"
.br
.ti -1c
.RI "#define \fBengine_err_cutoff\fP   -27"
.br
.ti -1c
.RI "#define \fBengine_err_nometis\fP   -28"
.br
.ti -1c
.RI "#define \fBengine_flag_none\fP   0"
.br
.ti -1c
.RI "#define \fBengine_flag_static\fP   1"
.br
.ti -1c
.RI "#define \fBengine_flag_localparts\fP   2"
.br
.ti -1c
.RI "#define \fBengine_flag_cuda\fP   4"
.br
.ti -1c
.RI "#define \fBengine_flag_explepot\fP   8"
.br
.ti -1c
.RI "#define \fBengine_flag_verlet\fP   16"
.br
.ti -1c
.RI "#define \fBengine_flag_verlet_pairwise\fP   32"
.br
.ti -1c
.RI "#define \fBengine_flag_affinity\fP   64"
.br
.ti -1c
.RI "#define \fBengine_flag_prefetch\fP   128"
.br
.ti -1c
.RI "#define \fBengine_flag_verlet_pseudo\fP   256"
.br
.ti -1c
.RI "#define \fBengine_flag_unsorted\fP   512"
.br
.ti -1c
.RI "#define \fBengine_flag_shake\fP   1024"
.br
.ti -1c
.RI "#define \fBengine_flag_mpi\fP   2048"
.br
.ti -1c
.RI "#define \fBengine_flag_parbonded\fP   4096"
.br
.ti -1c
.RI "#define \fBengine_flag_async\fP   8192"
.br
.ti -1c
.RI "#define \fBengine_flag_sets\fP   16384"
.br
.ti -1c
.RI "#define \fBengine_flag_nullpart\fP   32768"
.br
.ti -1c
.RI "#define \fBengine_bonds_chunk\fP   100"
.br
.ti -1c
.RI "#define \fBengine_angles_chunk\fP   100"
.br
.ti -1c
.RI "#define \fBengine_rigids_chunk\fP   50"
.br
.ti -1c
.RI "#define \fBengine_dihedrals_chunk\fP   100"
.br
.ti -1c
.RI "#define \fBengine_exclusions_chunk\fP   100"
.br
.ti -1c
.RI "#define \fBengine_readbuff\fP   16384"
.br
.ti -1c
.RI "#define \fBengine_maxgpu\fP   10"
.br
.ti -1c
.RI "#define \fBengine_pshake_steps\fP   20"
.br
.ti -1c
.RI "#define \fBengine_maxKcutoff\fP   2"
.br
.ti -1c
.RI "#define \fBengine_split_MPI\fP   1"
.br
.ti -1c
.RI "#define \fBengine_split_GPU\fP   2"
.br
.ti -1c
.RI "#define \fBengine_bonded_maxnrthreads\fP   16"
.br
.ti -1c
.RI "#define \fBengine_bonded_nrthreads\fP   ((omp_get_num_threads()<\fBengine_bonded_maxnrthreads\fP)?omp_get_num_threads():\fBengine_bonded_maxnrthreads\fP)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBengine_timer_step\fP = 0, \fBengine_timer_prepare\fP, \fBengine_timer_verlet\fP, \fBengine_timer_exchange1\fP, \fBengine_timer_nonbond\fP, \fBengine_timer_bonded\fP, \fBengine_timer_bonded_sort\fP, \fBengine_timer_bonds\fP, \fBengine_timer_angles\fP, \fBengine_timer_dihedrals\fP, \fBengine_timer_exclusions\fP, \fBengine_timer_advance\fP, \fBengine_timer_rigid\fP, \fBengine_timer_exchange2\fP, \fBengine_timer_shuffle\fP, \fBengine_timer_cuda_load\fP, \fBengine_timer_cuda_unload\fP, \fBengine_timer_cuda_dopairs\fP, \fBengine_timer_last\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBengine_addpot\fP (struct \fBengine\fP *\fBe\fP, struct \fBpotential\fP *p, int i, int j)"
.br
.RI "\fIAdd an interaction potential\&. \fP"
.ti -1c
.RI "int \fBengine_addtype\fP (struct \fBengine\fP *\fBe\fP, double mass, double charge, char *name, char *name2)"
.br
.RI "\fIAdd a type definition\&. \fP"
.ti -1c
.RI "int \fBengine_advance\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIUpdate the particle velocities and positions, re-shuffle if appropriate\&. \fP"
.ti -1c
.RI "int \fBengine_angle_addpot\fP (struct \fBengine\fP *\fBe\fP, struct \fBpotential\fP *p)"
.br
.RI "\fIAdd a angle potential\&. \fP"
.ti -1c
.RI "int \fBengine_angle_add\fP (struct \fBengine\fP *\fBe\fP, int i, int j, int k, int pid)"
.br
.RI "\fIAdd a angle interaction to the engine\&. \fP"
.ti -1c
.RI "int \fBengine_angle_eval\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fICompute the angled interactions stored in this engine\&. \fP"
.ti -1c
.RI "int \fBengine_barrier\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIBarrier routine to hold the \fCrunners\fP back\&. \fP"
.ti -1c
.RI "int \fBengine_bond_addpot\fP (struct \fBengine\fP *\fBe\fP, struct \fBpotential\fP *p, int i, int j)"
.br
.RI "\fIAdd a bond potential\&. \fP"
.ti -1c
.RI "int \fBengine_bond_add\fP (struct \fBengine\fP *\fBe\fP, int i, int j)"
.br
.RI "\fIAdd a bonded interaction to the engine\&. \fP"
.ti -1c
.RI "int \fBengine_bond_eval\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fICompute the bonded interactions stored in this engine\&. \fP"
.ti -1c
.RI "int \fBengine_bonded_eval\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fICompute all bonded interactions stored in this engine\&. \fP"
.ti -1c
.RI "int \fBengine_bonded_eval_sets\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fICompute all bonded interactions stored in this engine\&. \fP"
.ti -1c
.RI "int \fBengine_bonded_sets\fP (struct \fBengine\fP *\fBe\fP, int max_sets)"
.br
.RI "\fIAssemble non-conflicting sets of bonded interactions\&. \fP"
.ti -1c
.RI "int \fBengine_dihedral_add\fP (struct \fBengine\fP *\fBe\fP, int i, int j, int k, int l, int pid)"
.br
.RI "\fIAdd a dihedral interaction to the engine\&. \fP"
.ti -1c
.RI "int \fBengine_dihedral_addpot\fP (struct \fBengine\fP *\fBe\fP, struct \fBpotential\fP *p)"
.br
.RI "\fIAdd a dihedral potential\&. \fP"
.ti -1c
.RI "int \fBengine_dihedral_eval\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fICompute the dihedral interactions stored in this engine\&. \fP"
.ti -1c
.RI "int \fBengine_dump_PSF\fP (struct \fBengine\fP *\fBe\fP, FILE *psf, FILE *pdb, char *excl[], int nr_excl)"
.br
.RI "\fIDump the contents of the enginge to a PSF and PDB file\&. \fP"
.ti -1c
.RI "int \fBengine_exclusion_add\fP (struct \fBengine\fP *\fBe\fP, int i, int j)"
.br
.RI "\fIAdd a exclusioned interaction to the engine\&. \fP"
.ti -1c
.RI "int \fBengine_exclusion_eval\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fICompute the exclusioned interactions stored in this engine\&. \fP"
.ti -1c
.RI "int \fBengine_exclusion_shrink\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIRemove duplicate exclusions\&. \fP"
.ti -1c
.RI "int \fBengine_finalize\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIInitialize an \fBengine\fP with the given data and MPI enabled\&. \fP"
.ti -1c
.RI "int \fBengine_flush_ghosts\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIClear all particles from this \fBengine\fP's ghost cells\&. \fP"
.ti -1c
.RI "int \fBengine_flush\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIClear all particles from this \fBengine\fP\&. \fP"
.ti -1c
.RI "int \fBengine_gettype\fP (struct \fBengine\fP *\fBe\fP, char *name)"
.br
.RI "\fILook for a given type by name\&. \fP"
.ti -1c
.RI "int \fBengine_gettype2\fP (struct \fBengine\fP *\fBe\fP, char *name2)"
.br
.RI "\fILook for a given type by its second name\&. \fP"
.ti -1c
.RI "int \fBengine_init\fP (struct \fBengine\fP *\fBe\fP, const double *origin, const double *dim, double *L, double cutoff, unsigned int period, int max_type, unsigned int flags)"
.br
.RI "\fIInitialize an \fBengine\fP with the given data\&. \fP"
.ti -1c
.RI "int \fBengine_load_ghosts\fP (struct \fBengine\fP *\fBe\fP, double *\fBx\fP, double *v, int *type, int *pid, int *vid, double *q, unsigned int *flags, int N)"
.br
.RI "\fILoad a set of particle data as ghosts\&. \fP"
.ti -1c
.RI "int \fBengine_load\fP (struct \fBengine\fP *\fBe\fP, double *\fBx\fP, double *v, int *type, int *pid, int *vid, double *charge, unsigned int *flags, int N)"
.br
.RI "\fILoad a set of particle data\&. \fP"
.ti -1c
.RI "int \fBengine_nonbond_eval\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fICompute the nonbonded interactions in the current step\&. \fP"
.ti -1c
.RI "int \fBengine_read_cpf\fP (struct \fBengine\fP *\fBe\fP, int cpf, double \fBkappa\fP, double tol, int rigidH)"
.br
.RI "\fIRead the potentials from a CHARMM parameter file\&. \fP"
.ti -1c
.RI "int \fBengine_read_psf\fP (struct \fBengine\fP *\fBe\fP, int psf, int pdb)"
.br
.RI "\fIRead the simulation setup from a PSF and PDB file pair\&. \fP"
.ti -1c
.RI "int \fBengine_read_xplor\fP (struct \fBengine\fP *\fBe\fP, int xplor, double \fBkappa\fP, double tol, int rigidH)"
.br
.RI "\fIRead the potentials from a XPLOR parameter file\&. \fP"
.ti -1c
.RI "int \fBengine_rigid_add\fP (struct \fBengine\fP *\fBe\fP, int pid, int pjd, double d)"
.br
.RI "\fIAdd a rigid constraint to the engine\&. \fP"
.ti -1c
.RI "int \fBengine_rigid_eval\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIResolve the constraints\&. \fP"
.ti -1c
.RI "int \fBengine_rigid_sort\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fISplit the rigids into local, semilocal and non-local\&. \fP"
.ti -1c
.RI "int \fBengine_rigid_unsort\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIShuffle the rigid constraints randomly\&. \fP"
.ti -1c
.RI "int \fBengine_setexplepot\fP (struct \fBengine\fP *\fBe\fP, struct \fBpotential\fP *ep)"
.br
.RI "\fISet the explicit electrostatic potential\&. \fP"
.ti -1c
.RI "int \fBengine_shuffle\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIRe-shuffle the particles in the engine\&. \fP"
.ti -1c
.RI "int \fBengine_split_bisect\fP (struct \fBengine\fP *\fBe\fP, int N)"
.br
.RI "\fISplit the computational domain over a number of nodes using bisection\&. \fP"
.ti -1c
.RI "int \fBengine_split\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fISet-up the engine for distributed-memory parallel operation\&. \fP"
.ti -1c
.RI "int \fBengine_start_SPU\fP (struct \fBengine\fP *\fBe\fP, int nr_runners)"
.br
.RI "\fIStart the SPU-associated runners in the given \fBengine\fP\&. \fP"
.ti -1c
.RI "int \fBengine_start\fP (struct \fBengine\fP *\fBe\fP, int nr_runners, int nr_queues)"
.br
.RI "\fIStart the runners in the given \fBengine\fP\&. \fP"
.ti -1c
.RI "int \fBengine_step\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fIRun the engine for a single time step\&. \fP"
.ti -1c
.RI "int \fBengine_timers_reset\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fISet all the engine timers to 0\&. \fP"
.ti -1c
.RI "int \fBengine_unload_marked\fP (struct \fBengine\fP *\fBe\fP, double *\fBx\fP, double *v, int *type, int *pid, int *vid, double *q, unsigned int *flags, double *epot, int N)"
.br
.RI "\fIUnload a set of particle data from the marked cells of an \fBengine\fP\&. \fP"
.ti -1c
.RI "int \fBengine_unload_strays\fP (struct \fBengine\fP *\fBe\fP, double *\fBx\fP, double *v, int *type, int *pid, int *vid, double *q, unsigned int *flags, double *epot, int N)"
.br
.RI "\fIUnload real particles that may have wandered into a ghost cell\&. \fP"
.ti -1c
.RI "int \fBengine_unload\fP (struct \fBengine\fP *\fBe\fP, double *\fBx\fP, double *v, int *type, int *pid, int *vid, double *charge, unsigned int *flags, double *epot, int N)"
.br
.RI "\fIUnload a set of particle data from the \fBengine\fP\&. \fP"
.ti -1c
.RI "int \fBengine_verlet_update\fP (struct \fBengine\fP *\fBe\fP)"
.br
.RI "\fICheck if the Verlet-list needs to be updated\&. \fP"
.ti -1c
.RI "int \fBengine_split_METIS\fP (struct \fBengine\fP *\fBe\fP, int N, int flags)"
.br
.RI "\fISplit the computation domain over a number of nodes using METIS graph partitioning\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBengine_err\fP"
.br
.ti -1c
.RI "char * \fBengine_err_msg\fP []"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define engine_angles_chunk   100"

.SS "#define engine_bonded_maxnrthreads   16"

.SS "#define engine_bonded_nrthreads   ((omp_get_num_threads()<\fBengine_bonded_maxnrthreads\fP)?omp_get_num_threads():\fBengine_bonded_maxnrthreads\fP)"

.SS "#define engine_bonds_chunk   100"

.SS "#define engine_dihedrals_chunk   100"

.SS "#define engine_err_angle   -12"

.SS "#define engine_err_bond   -11"

.SS "#define engine_err_cell   -7"

.SS "#define engine_err_cpf   -16"

.SS "#define engine_err_cuda   -21"

.SS "#define engine_err_cudasp   -23"

.SS "#define engine_err_cutoff   -27"

.SS "#define engine_err_dihedral   -20"

.SS "#define engine_err_domain   -8"

.SS "#define engine_err_exclusion   -18"

.SS "#define engine_err_malloc   -2"

.SS "#define engine_err_maxparts   -24"

.SS "#define engine_err_mpi   -10"

.SS "#define engine_err_nocuda   -22"

.SS "#define engine_err_nometis   -28"

.SS "#define engine_err_nompi   -9"

.SS "#define engine_err_null   -1"

.SS "#define engine_err_ok   0"

.SS "#define engine_err_pdb   -15"

.SS "#define engine_err_potential   -17"

.SS "#define engine_err_psf   -14"

.SS "#define engine_err_pthread   -4"

.SS "#define engine_err_queue   -25"

.SS "#define engine_err_range   -6"

.SS "#define engine_err_reader   -13"

.SS "#define engine_err_rigid   -26"

.SS "#define engine_err_runner   -5"

.SS "#define engine_err_sets   -19"

.SS "#define engine_err_space   -3"

.SS "#define engine_exclusions_chunk   100"

.SS "#define engine_flag_affinity   64"

.SS "#define engine_flag_async   8192"

.SS "#define engine_flag_cuda   4"

.SS "#define engine_flag_explepot   8"

.SS "#define engine_flag_localparts   2"

.SS "#define engine_flag_mpi   2048"

.SS "#define engine_flag_none   0"

.SS "#define engine_flag_nullpart   32768"

.SS "#define engine_flag_parbonded   4096"

.SS "#define engine_flag_prefetch   128"

.SS "#define engine_flag_sets   16384"

.SS "#define engine_flag_shake   1024"

.SS "#define engine_flag_static   1"

.SS "#define engine_flag_unsorted   512"

.SS "#define engine_flag_verlet   16"

.SS "#define engine_flag_verlet_pairwise   32"

.SS "#define engine_flag_verlet_pseudo   256"

.SS "#define engine_maxgpu   10"

.SS "#define engine_maxKcutoff   2"

.SS "#define engine_pshake_steps   20"

.SS "#define engine_readbuff   16384"

.SS "#define engine_rigids_chunk   50"

.SS "#define engine_split_GPU   2"

.SS "#define engine_split_MPI   1"

.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"
Timmer IDs\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIengine_timer_step \fP\fP
.TP
\fB\fIengine_timer_prepare \fP\fP
.TP
\fB\fIengine_timer_verlet \fP\fP
.TP
\fB\fIengine_timer_exchange1 \fP\fP
.TP
\fB\fIengine_timer_nonbond \fP\fP
.TP
\fB\fIengine_timer_bonded \fP\fP
.TP
\fB\fIengine_timer_bonded_sort \fP\fP
.TP
\fB\fIengine_timer_bonds \fP\fP
.TP
\fB\fIengine_timer_angles \fP\fP
.TP
\fB\fIengine_timer_dihedrals \fP\fP
.TP
\fB\fIengine_timer_exclusions \fP\fP
.TP
\fB\fIengine_timer_advance \fP\fP
.TP
\fB\fIengine_timer_rigid \fP\fP
.TP
\fB\fIengine_timer_exchange2 \fP\fP
.TP
\fB\fIengine_timer_shuffle \fP\fP
.TP
\fB\fIengine_timer_cuda_load \fP\fP
.TP
\fB\fIengine_timer_cuda_unload \fP\fP
.TP
\fB\fIengine_timer_cuda_dopairs \fP\fP
.TP
\fB\fIengine_timer_last \fP\fP
.SH "Function Documentation"
.PP 
.SS "int engine_addpot (struct \fBengine\fP *e, struct \fBpotential\fP *p, inti, intj)"

.PP
Add an interaction potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIp\fP The \fBpotential\fP to add to the \fBengine\fP\&. 
.br
\fIi\fP ID of particle type for this interaction\&. 
.br
\fIj\fP ID of second particle type for this interaction\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
Adds the given potential for pairs of particles of type \fCi\fP and \fCj\fP, where \fCi\fP and \fCj\fP may be the same type ID\&. 
.SS "int engine_addtype (struct \fBengine\fP *e, doublemass, doublecharge, char *name, char *name2)"

.PP
Add a type definition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fImass\fP The particle type mass\&. 
.br
\fIcharge\fP The particle type charge\&. 
.br
\fIname\fP Particle name, can be \fCNULL\fP\&. 
.br
\fIname2\fP Particle second name, can be \fCNULL\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The type ID or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
The particle type ID must be an integer greater or equal to 0 and less than the value \fCmax_type\fP specified in \fBengine_init\fP\&. 
.SS "int engine_advance (struct \fBengine\fP *e)"

.PP
Update the particle velocities and positions, re-shuffle if appropriate\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP on which to run\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_angle_add (struct \fBengine\fP *e, inti, intj, intk, intpid)"

.PP
Add a angle interaction to the engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIi\fP The ID of the first \fBpart\fP\&. 
.br
\fIj\fP The ID of the second \fBpart\fP\&. 
.br
\fIk\fP The ID of the third \fBpart\fP\&. 
.br
\fIpid\fP Index of the \fBpotential\fP for this bond\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_angle_addpot (struct \fBengine\fP *e, struct \fBpotential\fP *p)"

.PP
Add a angle potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIp\fP The \fBpotential\fP to add to the \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The ID of the added angle potential or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_angle_eval (struct \fBengine\fP *e)"

.PP
Compute the angled interactions stored in this engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_barrier (struct \fBengine\fP *e)"

.PP
Barrier routine to hold the \fCrunners\fP back\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to wait on\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
After being initialized, and after every timestep, every \fBrunner\fP calls this routine which blocks until all the runners have returned and the \fBengine\fP signals the next timestep\&. 
.SS "int engine_bond_add (struct \fBengine\fP *e, inti, intj)"

.PP
Add a bonded interaction to the engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIi\fP The ID of the first \fBpart\fP\&. 
.br
\fIj\fP The ID of the second \fBpart\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_bond_addpot (struct \fBengine\fP *e, struct \fBpotential\fP *p, inti, intj)"

.PP
Add a bond potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIp\fP The \fBpotential\fP to add to the \fBengine\fP\&. 
.br
\fIi\fP ID of particle type for this interaction\&. 
.br
\fIj\fP ID of second particle type for this interaction\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
Adds the given bonded potential for pairs of particles of type \fCi\fP and \fCj\fP, where \fCi\fP and \fCj\fP may be the same type ID\&. 
.SS "int engine_bond_eval (struct \fBengine\fP *e)"

.PP
Compute the bonded interactions stored in this engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_bonded_eval (struct \fBengine\fP *e)"

.PP
Compute all bonded interactions stored in this engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
Does the same as \fBengine_bond_eval\fP, \fBengine_angle_eval\fP and #engine_dihedral eval, yet all in one go to avoid excessive updates of the particle forces\&. 
.SS "int engine_bonded_eval_sets (struct \fBengine\fP *e)"

.PP
Compute all bonded interactions stored in this engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
Does the same as \fBengine_bond_eval\fP, \fBengine_angle_eval\fP and #engine_dihedral eval, yet all in one go to avoid excessive updates of the particle forces\&. 
.SS "int engine_bonded_sets (struct \fBengine\fP *e, intmax_sets)"

.PP
Assemble non-conflicting sets of bonded interactions\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_dihedral_add (struct \fBengine\fP *e, inti, intj, intk, intl, intpid)"

.PP
Add a dihedral interaction to the engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIi\fP The ID of the first \fBpart\fP\&. 
.br
\fIj\fP The ID of the second \fBpart\fP\&. 
.br
\fIk\fP The ID of the third \fBpart\fP\&. 
.br
\fIl\fP The ID of the fourth \fBpart\fP\&. 
.br
\fIpid\fP Index of the \fBpotential\fP for this bond\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_dihedral_addpot (struct \fBengine\fP *e, struct \fBpotential\fP *p)"

.PP
Add a dihedral potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIp\fP The \fBpotential\fP to add to the \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The ID of the added dihedral potential or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_dihedral_eval (struct \fBengine\fP *e)"

.PP
Compute the dihedral interactions stored in this engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_dump_PSF (struct \fBengine\fP *e, FILE *psf, FILE *pdb, char *excl[], intnr_excl)"

.PP
Dump the contents of the enginge to a PSF and PDB file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIpsf\fP A pointer to \fCFILE\fP to which to write the PSF file\&. 
.br
\fIpdb\fP A pointer to \fCFILE\fP to which to write the PDB file\&.
.RE
.PP
If any of \fCpsf\fP or \fCpdb\fP are \fCNULL\fP, the respective output will not be generated\&.
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_exclusion_add (struct \fBengine\fP *e, inti, intj)"

.PP
Add a exclusioned interaction to the engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIi\fP The ID of the first \fBpart\fP\&. 
.br
\fIj\fP The ID of the second \fBpart\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_exclusion_eval (struct \fBengine\fP *e)"

.PP
Compute the exclusioned interactions stored in this engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_exclusion_shrink (struct \fBengine\fP *e)"

.PP
Remove duplicate exclusions\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of unique exclusions or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_finalize (struct \fBengine\fP *e)"

.PP
Initialize an \fBengine\fP with the given data and MPI enabled\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to initialize\&. 
.br
\fIorigin\fP An array of three doubles containing the cartesian origin of the space\&. 
.br
\fIdim\fP An array of three doubles containing the size of the space\&. 
.br
\fIL\fP The minimum cell edge length, should be at least \fCcutoff\fP\&. 
.br
\fIcutoff\fP The maximum interaction cutoff to use\&. 
.br
\fIperiod\fP A bitmask describing the periodicity of the domain (see \fBspace_periodic_full\fP)\&. 
.br
\fImax_type\fP The maximum number of particle types that will be used by this engine\&. 
.br
\fIflags\fP Bit-mask containing the flags for this engine\&. 
.br
\fIcomm\fP The MPI comm to use\&. 
.br
\fIrank\fP The ID of this node\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. Kill all runners and de-allocate the data of an engine\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIe\fP the \fBengine\fP to finalize\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_flush (struct \fBengine\fP *e)"

.PP
Clear all particles from this \fBengine\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to flush\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_flush_ghosts (struct \fBengine\fP *e)"

.PP
Clear all particles from this \fBengine\fP's ghost cells\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to flush\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_gettype (struct \fBengine\fP *e, char *name)"

.PP
Look for a given type by name\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIname\fP The type name\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The type ID or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_gettype2 (struct \fBengine\fP *e, char *name2)"

.PP
Look for a given type by its second name\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIname2\fP The type name2\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The type ID or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_init (struct \fBengine\fP *e, const double *origin, const double *dim, double *L, doublecutoff, unsigned intperiod, intmax_type, unsigned intflags)"

.PP
Initialize an \fBengine\fP with the given data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to initialize\&. 
.br
\fIorigin\fP An array of three doubles containing the cartesian origin of the space\&. 
.br
\fIdim\fP An array of three doubles containing the size of the space\&. 
.br
\fIL\fP The minimum cell edge length in each dimension\&. 
.br
\fIcutoff\fP The maximum interaction cutoff to use\&. 
.br
\fIperiod\fP A bitmask describing the periodicity of the domain (see \fBspace_periodic_full\fP)\&. 
.br
\fImax_type\fP The maximum number of particle types that will be used by this engine\&. 
.br
\fIflags\fP Bit-mask containing the flags for this engine\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_load (struct \fBengine\fP *e, double *x, double *v, int *type, int *pid, int *vid, double *q, unsigned int *flags, intN)"

.PP
Load a set of particle data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIx\fP An \fCN\fP times 3 array of the particle positions\&. 
.br
\fIv\fP An \fCN\fP times 3 array of the particle velocities\&. 
.br
\fItype\fP A vector of length \fCN\fP of the particle type IDs\&. 
.br
\fIpid\fP A vector of length \fCN\fP of the particle IDs\&. 
.br
\fIvid\fP A vector of length \fCN\fP of the particle virtual IDs\&. 
.br
\fIq\fP A vector of length \fCN\fP of the individual particle charges\&. 
.br
\fIflags\fP A vector of length \fCN\fP of the particle flags\&. 
.br
\fIN\fP the number of particles to load\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
If the parameters \fCv\fP, \fCflags\fP, \fCvid\fP or \fCq\fP are \fCNULL\fP, then these values are set to zero\&. 
.SS "int engine_load_ghosts (struct \fBengine\fP *e, double *x, double *v, int *type, int *pid, int *vid, double *q, unsigned int *flags, intN)"

.PP
Load a set of particle data as ghosts\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIx\fP An \fCN\fP times 3 array of the particle positions\&. 
.br
\fIv\fP An \fCN\fP times 3 array of the particle velocities\&. 
.br
\fItype\fP A vector of length \fCN\fP of the particle type IDs\&. 
.br
\fIpid\fP A vector of length \fCN\fP of the particle IDs\&. 
.br
\fIvid\fP A vector of length \fCN\fP of the particle virtual IDs\&. 
.br
\fIq\fP A vector of length \fCN\fP of the individual particle charges\&. 
.br
\fIflags\fP A vector of length \fCN\fP of the particle flags\&. 
.br
\fIN\fP the number of particles to load\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
If the parameters \fCv\fP, \fCflags\fP, \fCvid\fP or \fCq\fP are \fCNULL\fP, then these values are set to zero\&. 
.SS "int engine_nonbond_eval (struct \fBengine\fP *e)"

.PP
Compute the nonbonded interactions in the current step\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP on which to run\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
This routine advances the timestep counter by one, prepares the \fBspace\fP for a timestep, releases the \fBrunner\fP's associated with the \fBengine\fP and waits for them to finnish\&. 
.SS "int engine_read_cpf (struct \fBengine\fP *e, intcpf, doublekappa, doubletol, intrigidH)"

.PP
Read the potentials from a CHARMM parameter file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIcpf\fP The open CHARMM parameter file\&. 
.br
\fIkappa\fP The PME screening width\&. 
.br
\fItol\fP The absolute tolerance for interpolation\&. 
.br
\fIrigidH\fP Convert all bonds over a type starting with 'H' to a rigid constraint\&.
.RE
.PP
If \fCkappa\fP is zero, truncated Coulomb electrostatic interactions are assumed\&. If \fCkappa\fP is less than zero, no electrostatic interactions are computed\&.
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_read_psf (struct \fBengine\fP *e, intpsf, intpdb)"

.PP
Read the simulation setup from a PSF and PDB file pair\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIpsf\fP The open PSF file\&. 
.br
\fIpdb\fP The open PDB file\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_read_xplor (struct \fBengine\fP *e, intxplor, doublekappa, doubletol, intrigidH)"

.PP
Read the potentials from a XPLOR parameter file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIxplor\fP The open XPLOR parameter file\&. 
.br
\fIkappa\fP The PME screening width\&. 
.br
\fItol\fP The absolute tolerance for interpolation\&. 
.br
\fIrigidH\fP Convert all bonds over a type starting with 'H' to a rigid constraint\&.
.RE
.PP
If \fCkappa\fP is zero, truncated Coulomb electrostatic interactions are assumed\&. If \fCkappa\fP is less than zero, no electrostatic interactions are computed\&.
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_rigid_add (struct \fBengine\fP *e, intpid, intpjd, doubled)"

.PP
Add a rigid constraint to the engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIpid\fP The ID of the first \fBpart\fP\&. 
.br
\fIpjd\fP The ID of the second \fBpart\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The index of the rigid constraint or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
Beware that currently all particles have to have been inserted before the rigid constraints are added! 
.SS "int engine_rigid_eval (struct \fBengine\fP *e)"

.PP
Resolve the constraints\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
Note that if in parallel, \fBengine_rigid_sort\fP should be called before this routine\&. 
.SS "int engine_rigid_sort (struct \fBengine\fP *e)"

.PP
Split the rigids into local, semilocal and non-local\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_rigid_unsort (struct \fBengine\fP *e)"

.PP
Shuffle the rigid constraints randomly\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_setexplepot (struct \fBengine\fP *e, struct \fBpotential\fP *ep)"

.PP
Set the explicit electrostatic potential\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIep\fP The electrostatic \fBpotential\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
If \fCep\fP is not \fCNULL\fP, the flag \fBengine_flag_explepot\fP is set, otherwise it is cleared\&. 
.SS "int engine_shuffle (struct \fBengine\fP *e)"

.PP
Re-shuffle the particles in the engine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP on which to run\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_split (struct \fBengine\fP *e)"

.PP
Set-up the engine for distributed-memory parallel operation\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to set-up\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
This function assumes that \fBengine_split_bisect\fP or some similar function has already been called and that #nodeID, #nr_nodes as well as the \fBcell\fP \fCnodeIDs\fP have been set\&. 
.SS "int engine_split_bisect (struct \fBengine\fP *e, intN)"

.PP
Split the computational domain over a number of nodes using bisection\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to split up\&. 
.br
\fIN\fP The number of computational nodes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_split_METIS (struct \fBengine\fP *e, intN, intflags)"

.PP
Split the computation domain over a number of nodes using METIS graph partitioning\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to split up\&. 
.br
\fIN\fP The number of computational nodes\&. 
.br
\fIflags\fP Flag telling whether to split the space for MPI or for GPUs\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_start (struct \fBengine\fP *e, intnr_runners, intnr_queues)"

.PP
Start the runners in the given \fBengine\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to start\&. 
.br
\fInr_runners\fP The number of runners start\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
Allocates and starts the specified number of \fBrunner\fP\&. Also initializes the Verlet lists\&. 
.SS "int engine_start_SPU (struct \fBengine\fP *e, intnr_runners)"

.PP
Start the SPU-associated runners in the given \fBengine\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP to start\&. 
.br
\fInr_runners\fP The number of runners start\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
Allocates and starts the specified number of \fBrunner\fP\&. 
.SS "int engine_step (struct \fBengine\fP *e)"

.PP
Run the engine for a single time step\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP on which to run\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
This routine advances the timestep counter by one, prepares the \fBspace\fP for a timestep, releases the \fBrunner\fP's associated with the \fBengine\fP and waits for them to finnish\&.
.PP
Once all the \fBrunner\fP's are done, the particle velocities and positions are updated and the particles are re-sorted in the \fBspace\fP\&. 
.SS "int engine_timers_reset (struct \fBengine\fP *e)"

.PP
Set all the engine timers to 0\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SS "int engine_unload (struct \fBengine\fP *e, double *x, double *v, int *type, int *pid, int *vid, double *q, unsigned int *flags, double *epot, intN)"

.PP
Unload a set of particle data from the \fBengine\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIx\fP An \fCN\fP times 3 array of the particle positions\&. 
.br
\fIv\fP An \fCN\fP times 3 array of the particle velocities\&. 
.br
\fItype\fP A vector of length \fCN\fP of the particle type IDs\&. 
.br
\fIpid\fP A vector of length \fCN\fP of the particle IDs\&. 
.br
\fIvid\fP A vector of length \fCN\fP of the particle virtual IDs\&. 
.br
\fIq\fP A vector of length \fCN\fP of the individual particle charges\&. 
.br
\fIflags\fP A vector of length \fCN\fP of the particle flags\&. 
.br
\fIepot\fP A pointer to a #double in which to store the total potential energy\&. 
.br
\fIN\fP the maximum number of particles\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of particles unloaded or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
The fields \fCx\fP, \fCv\fP, \fCtype\fP, \fCpid\fP, \fCvid\fP, \fCq\fP, \fCepot\fP and/or \fCflags\fP may be NULL\&. 
.SS "int engine_unload_marked (struct \fBengine\fP *e, double *x, double *v, int *type, int *pid, int *vid, double *q, unsigned int *flags, double *epot, intN)"

.PP
Unload a set of particle data from the marked cells of an \fBengine\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIx\fP An \fCN\fP times 3 array of the particle positions\&. 
.br
\fIv\fP An \fCN\fP times 3 array of the particle velocities\&. 
.br
\fItype\fP A vector of length \fCN\fP of the particle type IDs\&. 
.br
\fIpid\fP A vector of length \fCN\fP of the particle IDs\&. 
.br
\fIvid\fP A vector of length \fCN\fP of the particle virtual IDs\&. 
.br
\fIq\fP A vector of length \fCN\fP of the individual particle charges\&. 
.br
\fIflags\fP A vector of length \fCN\fP of the particle flags\&. 
.br
\fIepot\fP A pointer to a #double in which to store the total potential energy\&. 
.br
\fIN\fP the maximum number of particles\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of particles unloaded or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
The fields \fCx\fP, \fCv\fP, \fCtype\fP, \fCpid\fP, \fCvid\fP, \fCq\fP, \fCepot\fP and/or \fCflags\fP may be NULL\&. 
.SS "int engine_unload_strays (struct \fBengine\fP *e, double *x, double *v, int *type, int *pid, int *vid, double *q, unsigned int *flags, double *epot, intN)"

.PP
Unload real particles that may have wandered into a ghost cell\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&. 
.br
\fIx\fP An \fCN\fP times 3 array of the particle positions\&. 
.br
\fIv\fP An \fCN\fP times 3 array of the particle velocities\&. 
.br
\fItype\fP A vector of length \fCN\fP of the particle type IDs\&. 
.br
\fIpid\fP A vector of length \fCN\fP of the particle IDs\&. 
.br
\fIvid\fP A vector of length \fCN\fP of the particle virtual IDs\&. 
.br
\fIq\fP A vector of length \fCN\fP of the individual particle charges\&. 
.br
\fIflags\fP A vector of length \fCN\fP of the particle flags\&. 
.br
\fIepot\fP A pointer to a #double in which to store the total potential energy\&. 
.br
\fIN\fP the maximum number of particles\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of particles unloaded or < 0 on error (see \fBengine_err\fP)\&.
.RE
.PP
The fields \fCx\fP, \fCv\fP, \fCtype\fP, \fCvid\fP, \fCpid\fP, \fCq\fP, \fCepot\fP and/or \fCflags\fP may be NULL\&. 
.SS "int engine_verlet_update (struct \fBengine\fP *e)"

.PP
Check if the Verlet-list needs to be updated\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The \fBengine\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBengine_err_ok\fP or < 0 on error (see \fBengine_err\fP)\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "int engine_err"
ID of the last error\&. 
.SS "char* engine_err_msg[]"
List of error messages\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for mdcore from the source code\&.
